var DragRace = function(lobby, players){
	this.lobby = lobby;
	this.schedule;
	this.players = players;
	
	this.dragons = {};
	
	this.track = {};
	
	this.dragonWidth = 300;
	this.dragonHeight = 155.2;
	
	this.dragonsCount;
	this.dragonsFinished = 0;
	
	this.start = function(){
		
		// TODO: generate course
		this.track.length = 12000;
		this.track.obstacles = [
			{type: "hurdle", x: 2000, y: 600},
			{type: "flyingHurdle", x: 5000, y: 420}
			// {type: "hurdle", x: 4000, triggered: false},
			// {type: "hurdle", x: 6000, triggered: false},
			// {type: "flyingHurdle", x: 5000, triggered: false},
			// {type: "hurdle", x: 7000, triggered: false},
		];
		
		this.track.markers = {
			3600: "fly", // Markers should be placed at multiples of the track sprite width.
			9600: "run"
		}
		
		var count = 0;
		for(var playerSocketID in this.players){
			count++;
			this.dragons[playerSocketID] = {raceState: "Pre", terrain: "land", x: 0, y: 600, vx: 5, vy: 0, jumping: false, keyPoll: {"KeyW": false, "KeyS": false, "Space": false}};
			
			var otherDragons = [];
			for(var otherPlayerID in this.players){
				if(otherPlayerID != playerSocketID){
					otherDragons.push({name: this.players[otherPlayerID].name});
				}
			}
			
			this.players[playerSocketID].socket.emit('launchGame', {gameType: "dragRace", gameData: {
				length: this.track.length,
				obstacles: this.track.obstacles,
				markers: this.track.markers,
				dragons: otherDragons
			}});
		}
		this.dragonsCount = count;
		
		
		for(var index in this.track.markers){
			this.track.obstacles.push({type: this.track.markers[index] + "Marker", x: +index});
		}
		
		this.track.obstacles.push({type: "finishLine", x: this.track.length});
		
		for(var index in this.track.obstacles){
			this.track.obstacles[index].triggered = [];
		}
		
		this.schedule = setInterval(this.update.bind(this), 1000/30);
		
	};
	
	this.startRace = function(){
		// turn all dragons from Pre to Racing
		for(var dragID in this.dragons){
			var dragon = this.dragons[dragID];
			dragon.raceState = "Racing";
		}
	};
	
	
	
	this.stop = function(){
		clearInterval(this.schedule);
	};
	
	this.playerReady = function(socketID){
		this.players[socketID].ready = true;
		
		var allReady = true;
		for(var playerSocketID in this.players){
			if(!this.players[playerSocketID].ready){
				allReady = false;
			}
		}
		
		if(allReady){
			for(var playerSocketID in this.players){
				// After this, clients will start in 4 seconds.
				this.players[playerSocketID].socket.emit('go');
				setTimeout(this.startRace.bind(this), 4000);
			}
		}
	};
	
	this.update = function(){
		// Carry out separate updating for each dragon
		for(var dragID in this.dragons){
			var dragon = this.dragons[dragID];
			switch(dragon.raceState){
				case "Racing":
					switch(dragon.terrain){
						case "land":
							if( dragon.jumping){
								dragon.vy += 2;
							}
							
							if(dragon.y > 600){
								dragon.y = 600;
								dragon.jumping = false;
								dragon.vy = 0;
							}
							break;
						case "sky":
							// Apply held keys W or S
							if(dragon.y > (-200 + this.dragonHeight) && (dragon.keyPoll["KeyW"] || dragon.keyPoll["Space"])){
								dragon.vy = Math.max(dragon.vy - 8, -20);
							}
							
							if(dragon.y < 450 && dragon.keyPoll["KeyS"]){
								dragon.vy = Math.min(dragon.vy + 8, 20);
							}
							
							dragon.vy *= 0.80 * 0.80;
							
							// push from edges of the sky play area: -200 <= y <= 450
							if(dragon.y > 450){
								dragon.y -= 8;
							}
							
							if(dragon.y < -200 + this.dragonHeight){
								dragon.y += 8;
							}
						
							break;						
					}
					
					dragon.x += 2*dragon.vx;
					dragon.y += 2*dragon.vy;
					dragon.vx = Math.min(10, dragon.vx + 0.04);
					this.checkObstacles();
					break;
					
				case "Waiting":
					if( dragon.jumping){
						dragon.vy += 2;
					}
					
					if(dragon.y > 600){
						dragon.y = 600;
						dragon.jumping = false;
						dragon.vy = 0;
					}
					
					dragon.x += 2*dragon.vx;
					dragon.y += 2*dragon.vy;
					dragon.vx = Math.max(dragon.vx - 0.2, 0);
					
					break;
			}
		}
		
		for(var playerSocketID in this.players){
			sock = this.players[playerSocketID].socket;
				
			sock.emit("gameUpdate", this.getStateForClient(sock.id));
		}
	};
	
	this.checkObstacles = function(){
		for(var id in this.dragons){
			var dragon = this.dragons[id];
			for(var index in this.track.obstacles){
				var obst = this.track.obstacles[index];
	
				switch(obst.type){
					case "finishLine":
						if(obst.triggered.indexOf(id) == -1 &&dragon.x >= obst.x){
							dragon.raceState = "Waiting";
							obst.triggered.push(id);
							this.dragonsFinished++;
							dragon.rank = this.dragonsFinished;
							this.players[id].points += 10 - 2*(dragon.rank - 1);
							
							if(this.dragonsFinished == this.dragonsCount){
								// everyone's done. Send the rankings
								for(var playerSocketID in this.players){
									var rank = this.dragons[playerSocketID].rank;
									
									var otherRanks = [];
									var otherPoints = [];
									for(var otherID in this.dragons){
										if(otherID != playerSocketID){
											otherRanks.push(this.dragons[otherID].rank);
											otherPoints.push(this.players[otherID].points);
										}
									}
									
									this.players[playerSocketID].socket.emit('gameEnd', {clientRank: rank, otherRanks: otherRanks, clientPoints: this.players[playerSocketID].points, otherPoints: otherPoints});
								}
								
								// Switch back to lobby
								setTimeout(this.lobby.closeGame.bind(this.lobby), 10000);
							}
						}
						break;
					case "hurdle":
						if(obst.triggered.indexOf(id) == -1){
							// Check positions to see if the curent dragon triggers this hurdle.
							var hurdleWidth = 50;
							var hurdleHeight = 100;
							
							var xCollision = dragon.x > obst.x - hurdleWidth/2 - (this.dragonWidth * 0.60)/2 && dragon.x < obst.x + hurdleWidth/2 + (this.dragonWidth*0.60)/2;
							var yCollision = dragon.y > obst.y - hurdleHeight && dragon.y < obst.y + this.dragonHeight;
							if(xCollision && yCollision){
								obst.triggered.push(id);
								
								dragon.vx /= 2;
							}
						}
						break;
					case "flyingHurdle":
						if(obst.triggered.indexOf(id) == -1){
							// Check positions to see if the curent dragon triggers this hurdle.
							var hurdleWidth = 50;
							var hurdleHeight = 200;
							var xCollision = dragon.x > obst.x - hurdleWidth/2 - (this.dragonWidth * 0.60)/2 && dragon.x < obst.x + hurdleWidth/2 + (this.dragonWidth*0.60)/2;
							var yCollision = dragon.y > obst.y - hurdleHeight && dragon.y < obst.y + this.dragonHeight;
							if(xCollision && yCollision){
								obst.triggered.push(id);
								
								dragon.vx /= 2;
							}
						}
						break;
					case "flyMarker":
						
						if(obst.triggered.indexOf(id) == -1 && dragon.x >= obst.x - 150){
							dragon.terrain = "sky";
							dragon.vy = -20;
							dragon.jumping = true;
							obst.triggered.push(id);
						}
						break;
					case "runMarker":
						if(obst.triggered.indexOf(id) == -1 && dragon.x >= obst.x + 200){
							
							dragon.terrain = "land";
							obst.triggered.push(id);
						}
						break;
				}
			}
		}
	};
	
	/*
		Sends data about the other dragons
	*/
	this.getStateForClient = function(socketID){
		var gameState = {};
		var otherDragons = [];
		var clientDragon = {x: this.dragons[socketID].x, y: this.dragons[socketID].y};
		for(var otherPlayerID in this.players){
			if(otherPlayerID != socketID){
				otherDragons.push({
					name: this.players[otherPlayerID].name,
					x: this.dragons[otherPlayerID].x,
					y: this.dragons[otherPlayerID].y
				});
			}
		}
		
		gameState.clientDragon = clientDragon;
		gameState.otherDragons = otherDragons;
		return gameState;
	};
	
	this.keyDown = function(fromSocket, keyCode){
		var dragon = this.dragons[fromSocket.id];
		if(!dragon.keyPoll[keyCode]){
			// key switched from up to down. Avoids the event flood that comes from holding a key down
			dragon.keyPoll[keyCode] = true;
			
			// Do trigger actions based on the input
			switch(keyCode){
				case "KeyW":
				case "Space":
					if(dragon.raceState == "Racing" && dragon.terrain == "land" && !dragon.jumping){
						// Jump!
						dragon.jumping = true;
						dragon.vy = -20;
					}
					break;
				case "KeyS":
					if(dragon.terrain == "land"){
						// Fireball!
					}
					break;
			}
		}
	};
	
	this.keyUp = function(fromSocket, keyCode){
		this.dragons[fromSocket.id].keyPoll[keyCode] = false;
	};
}

module.exports = DragRace;