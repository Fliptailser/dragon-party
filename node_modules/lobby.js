var p2 = require('p2');

/*
	Removes first instance of element from array.
*/
function arrayRemove(array, element){
	var index = array.indexOf(element);
	if (index > -1) {
		array.splice(index, 1);
	}
};

var Lobby = function(lobbyCode, hostSocketID, privateLobby){
	this.lobbyCode = lobbyCode;
	this.hostID = hostSocketID;
	this.nextHosts = []; // List of IDs.
	this.p2world = new p2.World();
	this.p2world.gravity = [0, -10];
	this.IDcount = 0;
	this.schedule = null;
	this.privateLobby = privateLobby;
	
	// Maps socket IDs to a map of keys to bools
	this.keyPolls = {};
	
	// Maps socket ids to player objects. Entity players[] is simply a list of keys from this.
	this.players = {};
	
	// Maps entity IDs to entity data.
	this.entities = {};
	
	this.start = function(){
		this.addWalls();
		
		// Update code
		this.schedule = setInterval(this.update.bind(this), 1000/30);
	};
	
	this.stop = function(){
		clearInterval(this.schedule);
	};
	
	this.update = function(){
		
		for(var entID in this.entities){
			ent = this.entities[entID];
			switch(ent.entityType){
				case "Dragon":
					var countA = 0;
					var countD = 0;
					for(var i = 0; i < ent.players.length; i++){
						var playerID = ent.players[i];
						if(this.keyPolls[playerID]){
							countA += this.keyPolls[playerID]["KeyA"] ? 1 : 0;
							countD += this.keyPolls[playerID]["KeyD"] ? 1 : 0;
						}
					}
					if(countA != countD){
						ent.body.velocity[0] = countD > countA ? 10 : -10;
					}
					break;
			}
			
			ent.body.velocity[0] *= 0.80;
			
			if(ent.body.angle > Math.PI / 12){
				ent.body.angle = Math.PI / 12;
			}
			if(ent.body.angle < -Math.PI / 12){
				ent.body.angle = -Math.PI / 12;
			}
		}
		
		this.p2world.step(1 / 30);
		
		for(var playerID in this.players){
			sock = this.players[playerID].socket;
			
			sock.emit("lobbyUpdate", this.getStateForClient(sock));
		}
	};
	
	/*
		Generates information for parts of the lobby's state that cannot be initialized solely by the client:
			Player positions and velocities
			
	*/
	this.getStateForClient = function(socket){
		var state = {};
		var entityState = [];
		for(var entID in this.entities){
			var entityData = this.entities[entID];
			
			// Contextualizes "controllable" based on the particular client.
			// These controllable entities can be updated more immediately by the client.
			
			entityState.push({
				id: entityData.id,
				name: this.players[entityData.players[0]].name,
				type: entityData.entityType,
				x: entityData.body.position[0],
				y: entityData.body.position[1],
				dx: entityData.body.velocity[0],
				dy: entityData.body.velocity[1],
				angle: entityData.body.angle,
				controllable: entityData.players.indexOf(socket.id) != -1
			});
		}
		
		state.entities = entityState;
		
		state.privateLobby = this.privateLobby;
		if(this.players[this.hostID]){
			state.hostName = this.players[this.hostID].name;
		}
		state.youHost = socket.id == this.hostID;
		state.lobbyCode = this.lobbyCode;
	
		return state;
	};
	
	this.addWalls = function(){
		var floor = new p2.Body({ 
			mass: 0, 
			position: [ 640 / 20, 700 / -20]
		});
		floor.addShape(new p2.Box({width:1280 / 20, height: 40 / 20}));
		this.p2world.addBody(floor);
		
		var ceil = new p2.Body({ 
			mass: 0, 
			position: [ 640 / 20, 20 / -20]
		});
		ceil.addShape(new p2.Box({width:1280 / 20, height: 40 / 20}));
		this.p2world.addBody(ceil);
		
		var wallLeft = new p2.Body({
			mass: 0,
			position: [ 20 / 20, 360 / -20]
		});
		wallLeft.addShape(new p2.Box({width: 40 / 20, height: 720 / 20}));
		this.p2world.addBody(wallLeft);
		
		var wallRight = new p2.Body({
			mass: 0,
			position: [ (1280 - 320) / 20, 360 / -20]
		});
		wallRight.addShape(new p2.Box({width: 40 / 20, height: 720 / 20}));
		this.p2world.addBody(wallRight);
	};
	
	this.addPlayer = function(player){
		console.log("Adding player " + player.name);
		this.players[player.socket.id] = player;
		this.nextHosts.push(player.socket.id);
		this.keyPolls[player.socket.id] = {};
		this.addDragon(player, Math.random() * 680 + 150, 450);
	};
	
	this.removePlayer = function(player){
		delete this.players[player.socket.id];
		arrayRemove(this.nextHosts, player.socket.id);
		delete this.keyPolls[player.socket.id];
		for(var entID in this.entities){
			var ent = this.entities[entID];
			if(ent.players.indexOf(player.socket.id) != -1){
				// The removed player could directly control this entity
				arrayRemove(ent.players, player.socket.id);
				
				// For now, remove dragons of players who disconnect.
				// Later, disconnected players should idle rather than abandon games in progress.
				if(ent.entityType == "Dragon"){
					this.p2world.removeBody(ent.body);
					delete this.entities[entID];
					
					for(var playerID in this.players){
						this.players[playerID].socket.emit('removeEntity', entID);
					}
					
				}
			}
		}
		
		// if the removed player was host, assign a new host.
		if(player.socket.id == this.hostID && this.nextHosts.length > 0){
			this.hostID = this.nextHosts[0];
		}
	};
	
	this.addDragon = function(player, x, y){
		console.log("Adding dragon.");
		var dragon = new p2.Body({
			mass: 100,
            position: [x / 20, y / -20],
            angle: 0,
            velocity: [0, 0],
            angularVelocity: 0
		});
		dragon.addShape(new p2.Box({width:10, height:5}));
		this.p2world.addBody(dragon);
		this.entities[this.IDcount] = {id: this.IDcount, players: [player.socket.id], body: dragon, entityType: "Dragon"};
		this.IDcount += 1;
	};
	
	this.startGame = function(){
		// TODO: Decide which game to play
		
		for(var playerID in this.players){
			this.players[playerID].socket.emit('startGame');
		}
	};
	
	this.keyDown = function(fromSocket, keyCode){
		
		switch(keyCode){
			case "Space":
				for(var entID in this.entities){
					ent = this.entities[entID];
					switch(ent.entityType){
						case "Dragon":
							if(ent.players.indexOf(fromSocket.id) != -1){
								ent.body.velocity[1] += 5;
							}
							break;
					}
				}
				break;
			default:
			
				// Keys that are down or up instead of triggers.
				this.keyPolls[fromSocket.id][keyCode] = true;
		}
		
	};
	
	this.keyUp = function(fromSocket, keyCode){
		this.keyPolls[fromSocket.id][keyCode] = false;
	};
};

module.exports = Lobby;