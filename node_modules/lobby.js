var p2 = require('p2');
var DragRace = require('dragRace.js');
var Snake = require('snake.js');
/*
	Removes first instance of element from array.
*/
function arrayRemove(array, element){
	var index = array.indexOf(element);
	if (index > -1) {
		array.splice(index, 1);
	}
};

var Lobby = function(lobbyCode, hostSocketID, privateLobby){
	this.lobbyCode = lobbyCode;
	this.hostID = hostSocketID;
	this.nextHosts = []; // List of IDs.
	this.p2world = new p2.World();
	this.p2world.gravity = [0, -10];
	this.IDcount = 0;
	this.schedule = null;
	this.privateLobby = privateLobby;
	this.paused = false;
	this.gamesRemaining = 2;
	
	// Maps socket IDs to a map of keys to bools
	this.keyPolls = {};
	
	// Maps socket ids to player objects. Entity players[] is simply a list of keys from this.
	this.players = {};
	
	// Maps entity IDs to entity data.
	this.entities = {};
	
	this.currentGame;
	
	this.start = function(){
		this.addWalls();
		
		// Update code
		this.schedule = setInterval(this.update.bind(this), 1000/30);
	};
	
	this.stop = function(){
		clearInterval(this.schedule);
	};
	
	this.update = function(){
		if(!this.paused){
			for(var entID in this.entities){
				ent = this.entities[entID];
				switch(ent.entityType){
					case "Dragon":
						var countA = 0;
						var countD = 0;
						for(var i = 0; i < ent.players.length; i++){
							var playerSocketID = ent.players[i];
							if(this.keyPolls[playerSocketID]){
								countA += this.keyPolls[playerSocketID]["KeyA"] ? 1 : 0;
								countD += this.keyPolls[playerSocketID]["KeyD"] ? 1 : 0;
							}
						}
						if(countA != countD){
							ent.body.velocity[0] = countD > countA ? 10 : -10;
						}
						break;
				}
				
				ent.body.velocity[0] *= 0.80;
				
				if(ent.body.angle > Math.PI / 12){
					ent.body.angle = Math.PI / 12;
				}
				if(ent.body.angle < -Math.PI / 12){
					ent.body.angle = -Math.PI / 12;
				}
			}
			
			this.p2world.step(1 / 30);
			
			for(var playerSocketID in this.players){
				sock = this.players[playerSocketID].socket;
				
				sock.emit("gameUpdate", this.getStateForClient(sock));
			}
		}
	};
	
	/*
		Generates information for parts of the lobby's state that cannot be initialized solely by the client:
			Player positions and velocities
			
	*/
	this.getStateForClient = function(socket){
		var state = {};
		var entityState = [];
		for(var entID in this.entities){
			var entityData = this.entities[entID];
			
			// Contextualizes "controllable" based on the particular client.
			// These controllable entities can be updated more immediately by the client.
			
			entityState.push({
				id: entityData.id,
				name: this.players[entityData.players[0]].name,
				type: entityData.entityType,
				x: entityData.body.position[0],
				y: entityData.body.position[1],
				dx: entityData.body.velocity[0],
				dy: entityData.body.velocity[1],
				angle: entityData.body.angle,
				controllable: entityData.players.indexOf(socket.id) != -1
			});
		}
		
		state.entities = entityState;
		
		state.privateLobby = this.privateLobby;
		if(this.players[this.hostID]){
			state.hostName = this.players[this.hostID].name;
		}
		state.youHost = socket.id == this.hostID;
		state.lobbyCode = this.lobbyCode;
	
		state.type = "lobby";
		return state;
	};
	
	this.addWalls = function(){
		var floor = new p2.Body({ 
			mass: 0, 
			position: [ 640 / 20, 700 / -20]
		});
		floor.addShape(new p2.Box({width:1280 / 20, height: 40 / 20}));
		this.p2world.addBody(floor);
		
		var ceil = new p2.Body({ 
			mass: 0, 
			position: [ 640 / 20, 20 / -20]
		});
		ceil.addShape(new p2.Box({width:1280 / 20, height: 40 / 20}));
		this.p2world.addBody(ceil);
		
		var wallLeft = new p2.Body({
			mass: 0,
			position: [ 20 / 20, 360 / -20]
		});
		wallLeft.addShape(new p2.Box({width: 40 / 20, height: 720 / 20}));
		this.p2world.addBody(wallLeft);
		
		var wallRight = new p2.Body({
			mass: 0,
			position: [ (1280 - 320) / 20, 360 / -20]
		});
		wallRight.addShape(new p2.Box({width: 40 / 20, height: 720 / 20}));
		this.p2world.addBody(wallRight);
	};
	
	this.addPlayer = function(player){
		console.log("Adding player " + player.name);
		this.players[player.socket.id] = player;
		this.nextHosts.push(player.socket.id);
		this.keyPolls[player.socket.id] = {};
		this.addDragon(player, Math.random() * 680 + 150, 450);
	};
	
	this.removePlayer = function(player){
		delete this.players[player.socket.id];
		arrayRemove(this.nextHosts, player.socket.id);
		delete this.keyPolls[player.socket.id];
		for(var entID in this.entities){
			var ent = this.entities[entID];
			if(ent.players.indexOf(player.socket.id) != -1){
				// The removed player could directly control this entity
				arrayRemove(ent.players, player.socket.id);
				
				// For now, remove dragons of players who disconnect.
				// Later, disconnected players should idle rather than abandon games in progress.
				if(ent.entityType == "Dragon"){
					this.p2world.removeBody(ent.body);
					delete this.entities[entID];
					
					for(var playerSocketID in this.players){
						this.players[playerSocketID].socket.emit('removeEntity', entID);
					}
					
				}
			}
		}
		
		// if the removed player was host, assign a new host.
		if(player.socket.id == this.hostID && this.nextHosts.length > 0){
			this.hostID = this.nextHosts[0];
		}
	};
	
	this.addDragon = function(player, x, y){
		console.log("Adding dragon.");
		var dragon = new p2.Body({
			mass: 100,
            position: [x / 20, y / -20],
            angle: 0,
            velocity: [0, 0],
            angularVelocity: 0
		});
		dragon.addShape(new p2.Box({width:10, height:5}));
		this.p2world.addBody(dragon);
		this.entities[this.IDcount] = {id: this.IDcount, players: [player.socket.id], body: dragon, entityType: "Dragon"};
		this.IDcount += 1;
	};
	
	this.startGame = function(){
		// TODO: Decide which game to play as a function of # games remaining or random
		this.paused = true;
		
		if(this.currentGame){
			this.currentGame.stop();
		}
		
		//this.currentGame = new DragRace(this, this.players);
		this.currentGame = new Snake(this, this.players);
		
		this.currentGame.start();
	};
	
	this.closeGame = function(){
		// Decide whether to go to results or a new minigame.
		this.gamesRemaining--;
		if(this.gamesRemaining > 0){
			this.startGame();
		}else{
			// Send clients a message to show results page.
			for(var playerSocketID in this.players){
				var player = this.players[playerSocketID];
				
				var otherPlayers = [];
				for(var otherPlayerID in this.players){
					if(otherPlayerID != playerSocketID){
						var other = this.players[otherPlayerID];
						otherPlayers.push({name: other.name, points: other.points});
					}
				}
				
				
				player.socket.emit('showResults', {client: {name: player.name, points: player.points}, otherPlayers: otherPlayers});
			}
			
			if(this.currentGame){
				this.currentGame.stop();
			}
			
			this.currentGame = null;
			
			// Go back to simulating the lobby, sending out updates. Let clients return to it from the results page on their own.
			this.paused = false;
			
		}
	};
	
	this.keyDown = function(fromSocket, keyCode){
		if(this.currentGame){
			this.currentGame.keyDown(fromSocket, keyCode);
		}else{
			switch(keyCode){
				case "Space":
					for(var entID in this.entities){
						ent = this.entities[entID];
						switch(ent.entityType){
							case "Dragon":
								if(ent.players.indexOf(fromSocket.id) != -1){
									ent.body.velocity[1] += 5;
								}
								break;
						}
					}
					break;
				default:
				
					// Keys that are down or up instead of triggers.
					this.keyPolls[fromSocket.id][keyCode] = true;
			}
		}
	};
	
	this.keyUp = function(fromSocket, keyCode){
		if(this.currentGame){
			this.currentGame.keyUp(fromSocket, keyCode);
		}else{
			this.keyPolls[fromSocket.id][keyCode] = false;
		}
	};
};

module.exports = Lobby;