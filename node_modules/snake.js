var Snake = function(lobby, players){
	this.lobby = lobby;
	this.schedule;
	this.players = players;
	
	this.snakes = {};
	this.foodLocations = [];
	this.liveSnakes = 0;
	
	this.state  = "pre";
	
	this.width = 24;
	this.height = 12;
	
	this.collisionLocations = {}; // [x + y*width] -> typestring
	
	
	this.speed = 6;
	this.timer = this.speed; // Counts upward every update until it 
	
	this.justAte = null; // Flags that tell clients when to play sound effects
	this.justDied = null;
	
	this.playhead = 0; // The server has to abstractly keep track of how long the music has been playing. It can't change speeds until the current music loop is finished.
	
	this.bgmDurations = {
		6: 25,
		4: 25 * 2/3,
		3: 13.75
	};
	
	this.start = function(){
		
		var spawnX = 4;
		var spawnY = 2;
		for(var playerSocketID in this.players){
			var position = spawnX + spawnY*this.width;
			this.snakes[playerSocketID] = {name: this.players[playerSocketID].name, x: spawnX, y: spawnY, tail: [position - 1, position - 1 - this.width, position - this.width], dir: 0, growth: 0, alive: true};
			this.liveSnakes += 1;
			this.collisionLocations[position] = "snake";
			this.collisionLocations[position - 1] = "snake";
			this.collisionLocations[position - 1 - this.width] = "snake";
			this.collisionLocations[position - this.width] = "snake";
			
			spawnX += 4;
			if(spawnX >= this.width){
				spawnX = 4;
				spawnY += 4;
			}
			
			if(spawnY >= this.height){
				spawnY = 4;
			}
		
			this.players[playerSocketID].socket.emit('launchGame', {gameType: "snake"});
			
			this.spawnFood();
		}
		
		// Updates happen every 1/12 of a second. 
		// By only updating after a certain number of intervals, we can make the game run at different speeds:
		// 12, 6, 4, 3, 2, or 1 updates per second.
		// Or in music terms:
		// 720, 360, 240, 180, 120, or 60 BPM.
		this.schedule = setInterval(this.update.bind(this), 1000/12);
	};
	
	this.spawnFood = function(){
		// Random grid location
		var k = Math.floor(Math.random() * this.width * this.height);
		
		while(this.collisionLocations[k]){
			// Reroll until k indicates an empty location
			k = Math.floor(Math.random() * this.width * this.height);
		}
		
		// Add food to list and collision system
		this.collisionLocations[k] = "food";
		this.foodLocations.push(k);
	
	}
	
	this.stop = function(){
		clearInterval(this.schedule);
	};
	
	this.playerReady = function(socketID){
		this.players[socketID].ready = true;
		
		var allReady = true;
		for(var playerSocketID in this.players){
			if(!this.players[playerSocketID].ready){
				allReady = false;
			}
		}
		
		if(allReady){
			for(var playerSocketID in this.players){
				// After this, clients will start in 4 seconds.
				this.players[playerSocketID].socket.emit('go');
				setTimeout(this.startRound.bind(this), 5000);
			}
		}
	};
	
	this.startRound = function(){
		this.state = "running";
	};
	
	this.update = function(){
		
		switch(this.state){
			case "pre":
				this.sendUpdates();
				break;
			case "running":
				if(this.timer == this.speed){
					this.timer = 1;
					this.justAte = false;
					this.justDied = false;
					// Advance snakes. 
					this.moveSnakes();
					this.music();
					
					this.sendUpdates();
				}else{
					this.timer += 1;
				}
				
				break;
			
		}
	};
	
	this.music = function(){
		
		// Move imaginary playhead forward
		this.playhead += this.speed / 12;
		
		// If the current BGM will be ending,
		if(this.playhead >= this.bgmDurations[this.speed]){
			// Reset the playhead.
			this.playhead = 0;
			
			// Look at the game state to see what speed to set the game to.
			var maxLength = 0;
			for(var id in this.snakes){
				var snek = this.snakes[id];
				maxLength = Math.max(maxLength, snek.tail.length + 1);
			}
			
			if(maxLength >= 20){
				this.speed = 3;
			}else if(maxLength >= 10){
				this.speed = 4;
			}else{
				this.speed = 6;
			}
			
		}
	};
	
	this.moveSnakes = function(){
		for (var id in this.snakes){
			var snake = this.snakes[id];
			if(snake.alive){
				// Get next snake position
				var nextX = snake.x;
				var nextY = snake.y;
				switch(snake.dir){
					case 0:
						nextX += 1;
						break;
					case 1:
						nextY += 1;
						break;
					case 2:
						nextX -= 1;
						break;
					case 3:
						nextY -= 1;
						break;
				}
				var nextPosition = nextX + nextY * this.width;
				
				// Check for collision at the next position (wall or snakes)
				if(this.collisionLocations[nextPosition]){
					switch(this.collisionLocations[nextPosition]){
						case "snake":
							console.log("Crashed into snake.");
							this.justDied = false;
							this.killSnake(snake);
							break;
						case "food":
							console.log("Ran into some food.");
							this.justAte = true;
							snake.growth += 1;
							delete this.collisionLocations[nextPosition];
							var foodIndex = this.foodLocations.indexOf(nextPosition);
							this.foodLocations.splice(foodIndex, 1);
							this.spawnFood();
							break;
					}
				}
				
				if(nextX < 0 || nextX >= this.width || nextY < 0 || nextY >= this.height){
						console.log("Crashed into wall.");
						this.justDied = false;
						this.killSnake(snake);
				}
				
				if(snake.alive){
					// Move snake to new location, push old location to tail, remove oldest part of tail if growth == 0
					snake.tail.push(snake.x + snake.y*this.width);
					
					if(snake.growth > 0){
						snake.growth -= 1;
					}else{
						delete this.collisionLocations[snake.tail.shift()];
					}
					
					snake.x = nextX;
					snake.y = nextY;
					this.collisionLocations[snake.x + snake.y*this.width] = "snake";
					
				}
			}
		}
	};
	
	this.sendUpdates = function(){
		for(var playerSocketID in this.players){
			sock = this.players[playerSocketID].socket;
			sock.emit("gameUpdate", this.getStateForClient(sock.id));
		}
	}
	
	// Kill snake and remove it from collisions
	this.killSnake = function(snake){
		snake.alive = false;
		console.log("Snake died.");
		delete this.collisionLocations[snake.x + this.width*snake.y];
		for(var i = 0; i < snake.tail.length; i++){
			delete this.collisionLocations[snake.tail[i]];
		}
		
		this.liveSnakes -= 1;
		if(this.liveSnakes == 0){
			// Transition to end-of-game
			// Trigger any events here
			
			this.state = "post";
			
			var snakeRanks = [];
			var index = 0;
			for(var snakeID in this.snakes){
				// Point gains tied to snake length, not ranking
				this.players[snakeID].points += this.snakes[snakeID].tail.length + 1;
				
				snakeRanks.push({index: index, length: this.snakes[snakeID].tail.length + 1, playerPoints: this.players[snakeID].points});
				index += 1;
			}
			
			snakeRanks.sort(function(a, b){
				return b.length - a.length;
			});
			
			for(var playerSocketID in this.players){
				this.players[playerSocketID].socket.emit('gameEnd', {snakeRanks: snakeRanks});
			}
			
			setTimeout(this.lobby.closeGame.bind(this.lobby), 10000);
		}
		
	}
	
	/*
		Sends data about the game
	*/
	this.getStateForClient = function(socketID){
		var gameState = {};
		gameState.state = this.state;
		gameState.collisionLocations = this.collisionLocations;
		gameState.snakes = [];
		gameState.liveSnakes = this.liveSnakes;
		gameState.foodLocations = this.foodLocations;
		gameState.speed = this.speed;
		gameState.justAte = this.justAte;
		gameState.justDied - this.justDied;
		
		var index = 0;
		for(var snakeID in this.snakes){
			gameState.snakes.push(this.snakes[snakeID]);
			
			if(snakeID == socketID){
				gameState.playerSnakeIndex = index;
			}
			
			index += 1;
		}
		return gameState;
	};
	
	this.keyDown = function(fromSocket, keyCode){
		var player = this.players[fromSocket.id];
		if(!player.keyPoll[keyCode]){
			// key switched from up to down. Avoids the event flood that comes from holding a key down
			player.keyPoll[keyCode] = true;
			
			// Do trigger actions based on the input
			if(this.state == "running"){
				switch(keyCode){
					case "KeyD":
						if(this.snakes[fromSocket.id].dir != 2)
							this.snakes[fromSocket.id].dir = 0;
						break;
					case "KeyA":
						if(this.snakes[fromSocket.id].dir != 0)
							this.snakes[fromSocket.id].dir = 2;
						break;
					case "KeyS":
						if(this.snakes[fromSocket.id].dir != 3)
							this.snakes[fromSocket.id].dir = 1;
						break;
					case "KeyW":
						if(this.snakes[fromSocket.id].dir != 1)
							this.snakes[fromSocket.id].dir = 3;
						break;
				}
			}
		}
	};
	
	this.keyUp = function(fromSocket, keyCode){
		this.players[fromSocket.id].keyPoll[keyCode] = false;
	};
	
		

}

module.exports = Snake;