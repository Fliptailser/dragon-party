var Snake = function(lobby, players){
	this.lobby = lobby;
	this.schedule;
	this.players = players;
	
	this.snakes = {};
	this.foodLocations = [];
	this.liveSnakes = 0;
	
	this.state  = "pre";
	
	this.width = 24;
	this.height = 12;
	
	this.collisionLocations = {}; // [x + y*width] -> typestring
	
	this.start = function(){
		
		var spawnX = 4;
		var spawnY = 2;
		for(var playerSocketID in this.players){
			var position = spawnX + spawnY*this.width;
			this.snakes[playerSocketID] = {name: this.players[playerSocketID].name, x: spawnX, y: spawnY, tail: [position - 1, position - 1 - this.width, position - this.width], dir: 0, growth: 0, alive: true};
			this.liveSnakes += 1;
			this.collisionLocations[position] = "snake";
			this.collisionLocations[position - 1] = "snake";
			this.collisionLocations[position - 1 - this.width] = "snake";
			this.collisionLocations[position - this.width] = "snake";
			
			spawnX += 4;
			if(spawnX >= this.width){
				spawnX = 4;
				spawnY += 4;
			}
			
			if(spawnY >= this.height){
				spawnY = 4;
			}
		
			this.players[playerSocketID].socket.emit('launchGame', {gameType: "snake"});
			
			this.spawnFood();
		}
		
		this.schedule = setInterval(this.update.bind(this), 1000/2);
	};
	
	this.spawnFood = function(){
		// Random grid location
		var k = Math.floor(Math.random() * this.width * this.height);
		
		while(this.collisionLocations[k]){
			// Reroll until k indicates an empty location
			k = Math.floor(Math.random() * this.width * this.height);
		}
		
		// Add food to list and collision system
		this.collisionLocations[k] = "food";
		this.foodLocations.push(k);
	
	}
	
	this.stop = function(){
		clearInterval(this.schedule);
	};
	
	this.playerReady = function(socketID){
		this.players[socketID].ready = true;
		
		var allReady = true;
		for(var playerSocketID in this.players){
			if(!this.players[playerSocketID].ready){
				allReady = false;
			}
		}
		
		if(allReady){
			for(var playerSocketID in this.players){
				// After this, clients will start in 4 seconds.
				this.players[playerSocketID].socket.emit('go');
				setTimeout(this.startRound.bind(this), 5000);
			}
		}
	};
	
	this.startRound = function(){
		this.state = "running";
	};
	
	this.update = function(){
		switch(this.state){
			case "pre":
			
				break;
			case "running":
				// Advance snakes. 
				for (var id in this.snakes){
					var snake = this.snakes[id];
					if(snake.alive){
						// Get next snake position
						var nextX = snake.x;
						var nextY = snake.y;
						switch(snake.dir){
							case 0:
								nextX += 1;
								break;
							case 1:
								nextY += 1;
								break;
							case 2:
								nextX -= 1;
								break;
							case 3:
								nextY -= 1;
								break;
						}
						var nextPosition = nextX + nextY * this.width;
						
						// Check for collision at the next position (wall or snakes)
						if(this.collisionLocations[nextPosition]){
							switch(this.collisionLocations[nextPosition]){
								case "snake":
									console.log("Crashed into snake.");
									this.killSnake(snake);
									break;
								case "food":
									console.log("Ran into some food.");
									snake.growth += 1;
									delete this.collisionLocations[nextPosition];
									var foodIndex = this.foodLocations.indexOf(nextPosition);
									this.foodLocations.splice(foodIndex, 1);
									this.spawnFood();
									break;
							}
						}
						
						if(nextX < 0 || nextX >= this.width || nextY < 0 || nextY >= this.height){
								console.log("Crashed into wall.");
								this.killSnake(snake);
						}
						
						if(snake.alive){
							// Move snake to new location, push old location to tail, remove oldest part of tail if growth == 0
							snake.tail.push(snake.x + snake.y*this.width);
							
							if(snake.growth > 0){
								snake.growth -= 1;
							}else{
								delete this.collisionLocations[snake.tail.shift()];
							}
							
							snake.x = nextX;
							snake.y = nextY;
							this.collisionLocations[snake.x + snake.y*this.width] = "snake";
							
						}
					}
				}
				break;
			
		}
		
		for(var playerSocketID in this.players){
			sock = this.players[playerSocketID].socket;
			sock.emit("gameUpdate", this.getStateForClient(sock.id));
		}
	};
	
	// Kill snake and remove it from collisions
	this.killSnake = function(snake){
		snake.alive = false;
		console.log("Snake died.");
		delete this.collisionLocations[snake.x + this.width*snake.y];
		for(var i = 0; i < snake.tail.length; i++){
			delete this.collisionLocations[snake.tail[i]];
		}
		
		this.liveSnakes -= 1;
		if(this.liveSnakes == 0){
			// Transition to end-of-game
			// Trigger any events here
			
			this.state = "post";
			
			var snakeRanks = [];
			var index = 0;
			for(var snakeID in this.snakes){
				// Point gains tied to snake length, not ranking
				this.players[snakeID].points += this.snakes[snakeID].tail.length + 1;
				
				snakeRanks.push({index: index, length: this.snakes[snakeID].tail.length + 1, playerPoints: this.players[snakeID].points});
				index += 1;
			}
			
			snakeRanks.sort(function(a, b){
				return b.length - a.length;
			});
			
			for(var playerSocketID in this.players){
				this.players[playerSocketID].socket.emit('gameEnd', {snakeRanks: snakeRanks});
			}
			
			setTimeout(this.lobby.closeGame.bind(this.lobby), 10000);
		}
		
	}
	
	/*
		Sends data about the game
	*/
	this.getStateForClient = function(socketID){
		var gameState = {};
		gameState.state = this.state;
		gameState.collisionLocations = this.collisionLocations;
		gameState.snakes = [];
		gameState.liveSnakes = this.liveSnakes;
		gameState.foodLocations = this.foodLocations;
		
		var index = 0;
		for(var snakeID in this.snakes){
			gameState.snakes.push(this.snakes[snakeID]);
			
			if(snakeID == socketID){
				gameState.playerSnakeIndex = index;
			}
			
			index += 1;
		}
		return gameState;
	};
	
	this.keyDown = function(fromSocket, keyCode){
		var player = this.players[fromSocket.id];
		if(!player.keyPoll[keyCode]){
			// key switched from up to down. Avoids the event flood that comes from holding a key down
			player.keyPoll[keyCode] = true;
			
			// Do trigger actions based on the input
			if(this.state == "running"){
				switch(keyCode){
					case "KeyD":
						this.snakes[fromSocket.id].dir = 0;
						break;
					case "KeyA":
						this.snakes[fromSocket.id].dir = 2;
						break;
					case "KeyS":
						this.snakes[fromSocket.id].dir = 1;
						break;
					case "KeyW":
						this.snakes[fromSocket.id].dir = 3;
						break;
				}
			}
		}
	};
	
	this.keyUp = function(fromSocket, keyCode){
		this.players[fromSocket.id].keyPoll[keyCode] = false;
	};
	
		

}

module.exports = Snake;