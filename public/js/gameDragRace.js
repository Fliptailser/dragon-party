/*
	DRAG RACE
	
	Each player runs horizontally down a track full of obstacles. The dragons run at the same speed unless they hit an obstacle, which slows them for a moment.
	The local player is always in front. The other players in the match can be seen in parallax in the background.
	Obstacles are generated by the server and are the same for every player.
	The game ends when all dragons have reached the end.
	
	Actions include:
	
	(Ground)
	Space or W: Jump.
	D or S: Breath attack. This takes a while to recharge.
	
	(Air or Water)
	Space or W: Ascend.
	S: Dive.
	
	Obstacles include:
	
	(Ground)
	Hurdle: A classic hurdle to jump over.
	Flying hurdle: Jumping will send you into this hurdle.
	
	(Air)
	Ring: Fly through the ring for a speed boost, of course.
	Flying hurdle
	
	
*/
var gameDragRaceState = {
	subState: "Pre",
	
	trackLength: null,
	
	trackSpeed: 5,
	
	track: [],
	
	trackMode: "land",
	
	bgm: null,
	// The nonlocal dragons send their x position.
	otherDragons: [],
	
	localDragon: null,
	
	keyPoll: {"KeyW": false, "KeyS": false, "Space": false},
	
	 // scenery groups
	 backdropGroup: null,
	 
	 backGroup: null,
	 midGroup: null,
	 frontGroup: null,
	 
	/*
		gameData: Information for each of the obstacles in the race, generated beforehand by the server.
	*/
	init: function(gameData){
		this.subState =  "Pre";
	
		this.trackLength =  null;
		
		this.trackSpeed =  5;
		
		this.track =  [];
		
		this.trackMode =  "land";
		
		this.bgm =  null;
		// The nonlocal dragons send their x position.
		this.otherDragons =  [];
		
		this.localDragon =  null;
		
		this.keyPoll =  {"KeyW" :  false, "KeyS" : false, "Space" :  false};
		
		 // scenery groups
		this.backdropGroup =  null;
		 
		this.backGroup =  null;
		this.midGroup =  null;
		 this.frontGroup =  null;
		
		this.bgm = game.add.audio('amazed', 0.80, true);
		// Parse the data and prepare the obstacle objects as well as dragons
		this.otherDragons = [];
		
		backdropGroup = game.add.group();
	 
		backGroup = game.add.group();
		midGroup = game.add.group(); // dragons and stuff
		frontGroup = game.add.group();
		
		this.trackLength = gameData.length;
		
		var dragonSprite = game.add.sprite(0, 600, 'dragonGreen', 0, midGroup);
		dragonSprite.anchor.setTo(0.5,0.90);
		dragonSprite.scale.x = 0.2;
		dragonSprite.scale.y = 0.2;
		dragonSprite.animations.add('walkright', [0,1,2,3], 8, true);
		this.localDragon = {sprite: dragonSprite, name: playerData.name, jumping: false, vy: 0};
		
		for(var i = 0; i < gameData.dragons.length; i++){
			var otherDragon = gameData.dragons[i];
			var otherDragonSprite = game.add.sprite(0, 600, 'dragonGreen',0, backGroup);
			otherDragonSprite.anchor.setTo(0.5,0.90);
			otherDragonSprite.scale.x = 0.2;
			otherDragonSprite.scale.y = 0.2;
			otherDragonSprite.alpha = 0.5;
			otherDragonSprite.animations.add('walkright', [0,1,2,3], 8, true);
			this.otherDragons.push({name: otherDragon.name, sprite: otherDragonSprite});
		}
		
		for(var i = -1000; i <= this.trackLength + 1000; i += 1000){
			var skySection = game.add.sprite(i, -250, 'sky', 0, backdropGroup);
			skySection.visible = false;
			this.track.push({type: "skyBackdrop", sprite: skySection, parallax: 0.5});
		}
		
		// Set track and markers
		var mode = "run";
		for(var i = -1200; i <= this.trackLength + 1200; i += 1200){
			if(gameData.markers[i]){
				mode = gameData.markers[i];
				
				// Anything that needs to be placed by each marker goes here
				switch(mode){
					case "run":
						for(var k = 0; k < 3; k++){
							var landingArrow = game.add.sprite(i - 250*k, 450, 'arrow', 0, backGroup);
							landingArrow.angle = 90;
							landingArrow.anchor.setTo(0.5,0.5);
							landingArrow.visible = false;
							this.track.push({type: "arrow", sprite: landingArrow});
						}
						break;
					case "fly":
						for(var k = 0; k < 3; k++){
							var takeoffArrow = game.add.sprite(i - 250*k, 500, 'arrow', 0, backGroup);
							takeoffArrow.angle = -90;
							takeoffArrow.anchor.setTo(0.5,0.5);
							takeoffArrow.visible = false;
							this.track.push({type: "arrow", sprite: takeoffArrow});
						}
						break;
				}
				this.track.push({type: mode + "Marker", x: i, triggered: false});
				
			}
			
			switch(mode){
				case "run":
					var trackSection = game.add.sprite(i, 600, 'track', 0, midGroup);
					trackSection.anchor.setTo(0, 0.0);
					trackSection.visible = false;
					this.track.push({type: "track", sprite: trackSection});
					break;
				case "fly":
					var trackSection = game.add.sprite(i, 600, 'skyTrack', 0, midGroup);
					trackSection.anchor.setTo(0, 0.0);
					trackSection.visible = false;
					this.track.push({type: "skyTrack", sprite: trackSection});
					
					
			}
			
			
		}
				
		var finishLine = game.add.sprite(this.trackLength, 600, 'finishLine', 0, midGroup);
		finishLine.visible = false;
		finishLine.anchor.setTo(0, 0);
		this.track.push({type: "finishLine", sprite: finishLine});
		
		for(var i in gameData.obstacles){
			var obstacle = gameData.obstacles[i];
			switch(obstacle.type){
				case "hurdle":
					var hurdleSprite = game.add.sprite(obstacle.x, 600, 'hurdle', 0, frontGroup);
					hurdleSprite.visible = false;
					hurdleSprite.scale.y = 0.5;
					hurdleSprite.anchor.setTo(0.5,1.0);
					this.track.push({type: obstacle.type, sprite: hurdleSprite, triggered: false});
					break;
					
				case "flyingHurdle":
					var hurdleSprite = game.add.sprite(obstacle.x, obstacle.y, 'hurdle', 0, frontGroup);
					hurdleSprite.visible = false;
					hurdleSprite.scale.y = 1.0;
					hurdleSprite.anchor.setTo(0.5,1.0);
					this.track.push({type: obstacle.type, sprite: hurdleSprite, triggered: false});
					break;
			}
		}
		
	},
	
	create: function(){
		game.sound.stopAll();
		game.stage.backgroundColor = '#E8AC46';
		// Fade in from black
		// Info screen: Splash page with instructions for the minigame. "Game starts in 10" text/timer along the bottom.
		var gameTitleLabel = game.add.text(100, 50, "Drag Race", { font: '80px Bubblegum Sans', fill: '#ddddff'});
		var instruction1 = game.add.text(200, 150, "Race to the finish and dodge the obstacles!", { font: '50px Bubblegum Sans', fill: '#ddddff'});
		var instructionTimerText = game.add.text(900, 650, "Game starts in 10", { font: '50px Bubblegum Sans', fill: '#ddddff'});
		game.camera.flash(0x000000, 1000);
		var crowd = game.add.audio('sportsCrowd', 0.025, true);
		crowd.play();
		// TODO: this is off for faster testing
		// game.time.events.add(Phaser.Timer.SECOND * 1, function(){ instructionTimerText.text = "Game starts in 9";}, this);
		// game.time.events.add(Phaser.Timer.SECOND * 2, function(){ instructionTimerText.text = "Game starts in 8";}, this);
		// game.time.events.add(Phaser.Timer.SECOND * 3, function(){ instructionTimerText.text = "Game starts in 7";}, this);
		// game.time.events.add(Phaser.Timer.SECOND * 4, function(){ instructionTimerText.text = "Game starts in 6";}, this);
		// game.time.events.add(Phaser.Timer.SECOND * 5, function(){ instructionTimerText.text = "Game starts in 5";}, this);
		// game.time.events.add(Phaser.Timer.SECOND * 6, function(){ instructionTimerText.text = "Game starts in 4";}, this);
		game.time.events.add(Phaser.Timer.SECOND * 1, function(){ instructionTimerText.text = "Game starts in 3";}, this);
		game.time.events.add(Phaser.Timer.SECOND * 2, function(){ instructionTimerText.text = "Game starts in 2";}, this);
		game.time.events.add(Phaser.Timer.SECOND * 3, function(){ instructionTimerText.text = "Game starts in 1";}, this);
		game.time.events.add(Phaser.Timer.SECOND * 4, function(){ instructionTimerText.text = "Game start!";}, this);
		
		// White transition
		game.time.events.add(Phaser.Timer.SECOND * 5, function(){
			//crowd.fadeTo(2000, 0.10);
			game.camera.fade(0xFFFFFF, 1000);
			game.camera.onFadeComplete.add(function(){
				// Hide instructions
				game.stage.backgroundColor = '#7FDBF0';
				gameTitleLabel.destroy();
				instruction1.destroy();
				instructionTimerText.destroy();
				// Intro scene. All the sprites are set up.
				// Clients automatically tell the server they're ready at the end of this scene.
				this.showTrack();
				
				
				
				
				game.camera.bounds  = null;
				game.camera.focusOnXY(this.localDragon.sprite.x + 400, 360);
				
				socket.emit("gameReady");
				
				
				game.camera.flash(0xFFFFFF, 1000);
			},this);
		}, this);
		
		
		
	},
	
	go: function(){
		game.time.events.add(Phaser.Timer.SECOND * 1, function(){
			game.sound.play('fanfare', 0.60);
		});
		
		game.time.events.add(Phaser.Timer.SECOND * 4, function(){
			
			this.bgm.play();
			this.subState = "Racing";
			
		}, this);
		
	},
	
	gameEnd: function(data){
		game.time.events.add(Phaser.Timer.SECOND * 1, function(){
			game.sound.play('fanfare', 0.60);
			game.add.text(game.camera.x + game.camera.width/2 + 50, game.camera.y + 150, "You placed " + data.clientRank + ordinalSuffix(data.clientRank) + "!", { font: '80px Bubblegum Sans', fill: '#ddddff'});
		});
		
		var leaderBoard1 = [];
		game.time.events.add(Phaser.Timer.SECOND * 5, function(){
			// Show point gains
			// Play sound effect TODO
			for(var i in this.otherDragons){
				var otherDragon = this.otherDragons[i];
				otherDragon.points = data.otherPoints[i];
				leaderBoard1.push(game.add.text(game.camera.x + 100, 75 + 50*data.otherRanks[i], data.otherRanks[i] + ordinalSuffix(data.otherRanks[i]), { font: '60px Bubblegum Sans', fill: '#ddddff'}));
				leaderBoard1.push(game.add.text(game.camera.x + 225, 75 + 50*data.otherRanks[i], otherDragon.name, { font: '60px Bubblegum Sans', fill: '#ddddff'}));
				leaderBoard1.push(game.add.text(game.camera.x + 450, 75 + 50*data.otherRanks[i], "+" + (10 - 2*(data.otherRanks[i] - 1)), { font: '60px Bubblegum Sans', fill: '#ddddff'}));
			}
			this.localDragon.points = data.clientPoints;
			leaderBoard1.push(game.add.text(game.camera.x + 100, 75 + 50*data.clientRank, data.clientRank + ordinalSuffix(data.clientRank), { font: '60px Bubblegum Sans', fill: '#ddddff'}));
			leaderBoard1.push(game.add.text(game.camera.x + 225, 75 + 50*data.clientRank, this.localDragon.name, { font: '60px Bubblegum Sans', fill: '#ddddff'}));
			leaderBoard1.push(game.add.text(game.camera.x + 450, 75 + 50*data.clientRank, "+" + (10 - 2*(data.clientRank - 1)), { font: '60px Bubblegum Sans', fill: '#ddddff'}));
		}, this);
		
		game.time.events.add(Phaser.Timer.SECOND * 7, function(){
			for(var i in leaderBoard1){
				leaderBoard1[i].destroy();
			}
			
			// Show point totals and wait for the server to change
			// Play harder sound effect TODO
			var list = [this.localDragon];
			for(var i in this.otherDragons){
				list.push(this.otherDragons[i]);
			}
			
			list.sort(function(a, b){
				return b.points - a.points;
			});
			
			for(var i = 0; i < list.length; i++){
				var dragon = list[i];
				var rank = i + 1;
				leaderBoard1.push(game.add.text(game.camera.x + 100, 50 + 60*rank, rank + ordinalSuffix(rank), { font: '60px Bubblegum Sans', fill: '#ddddff'}));
				leaderBoard1.push(game.add.text(game.camera.x + 225, 50 + 60*rank, dragon.name, { font: '60px Bubblegum Sans', fill: '#ddddff'}));
				leaderBoard1.push(game.add.text(game.camera.x + 450, 50 + 60*rank, dragon.points, { font: '60px Bubblegum Sans', fill: '#ddddff'}));
			}
			
		}, this);
		
		
	},
	
	showTrack: function(){
		for(var index in this.track){
			if(this.track[index].sprite){
				this.track[index].sprite.visible = true;
			}
		}
	},
	
	trackCamera: function(){
		var currentTargetY = game.camera.view.y + game.camera.height/2;
		switch(this.trackMode){
			case "land":
				game.camera.focusOnXY(this.localDragon.sprite.x + 400, currentTargetY + (360 - currentTargetY) * 0.05);
				
				break;
			case "sky":
				game.camera.focusOnXY(this.localDragon.sprite.x + 400, currentTargetY + (125 - currentTargetY) * 0.05);
				
				break;
		}
	},
	
	serverUpdate: function(gameState){
		if(gameState.type != "lobby"){
			this.localDragon.sprite.x = gameState.clientDragon.x;
			this.localDragon.sprite.y = gameState.clientDragon.y;
			
			for(var i = 0; i < this.otherDragons.length; i++){
				var other = this.otherDragons[i].sprite;
				other.x = gameState.otherDragons[i].x;
				other.y = gameState.otherDragons[i].y;
			}
		}
	},
	
	update: function(){
		switch(this.subState){
			case "Racing":
				this.localDragon.sprite.animations.play('walkright');
				this.trackCamera();
				
				switch(this.trackMode){
					case "land":
						// gravity
						if( this.localDragon.jumping){
							this.localDragon.vy += 1;
						}
						
						// keep from falling through the ground
						if(this.localDragon.sprite.y > 600){
							this.localDragon.sprite.y = 600;
							this.localDragon.jumping = false;
							this.localDragon.vy = 0;
						}
						break;
					case "sky":
						// Apply held keys W or S
						if(this.localDragon.sprite.y > (-200 + this.localDragon.sprite.height) && (this.keyPoll["KeyW"] || this.keyPoll["Space"])){
							this.localDragon.vy = Math.max(this.localDragon.vy - 4, -20);
						}
						
						if(this.localDragon.sprite.y < 450 && this.keyPoll["KeyS"]){
							this.localDragon.vy = Math.min(this.localDragon.vy + 4, 20);
						}
						
						this.localDragon.vy *= 0.80;
						
						// push from edges of the sky play area: -200 <= y <= 450
						if(this.localDragon.sprite.y > 450){
							this.localDragon.sprite.y -= 4;
						}
						
						if(this.localDragon.sprite.y < -200 + this.localDragon.sprite.height){
							this.localDragon.sprite.y += 4;
						}
						break;
						
					default:
				}
				
				
				// Move dragon vertically
				this.localDragon.sprite.y += this.localDragon.vy;
				
				
				// Move obstacles leftward and check behavior
				this.scroll();
				this.trackSpeed = Math.min(10, this.trackSpeed + 0.02);
				this.checkTrack();
				break;
			case "Waiting":
				// gravity
				if( this.localDragon.jumping){
					this.localDragon.vy += 1;
				}
				
				if(this.localDragon.sprite.y > 600){
					this.localDragon.sprite.y = 600;
					this.localDragon.jumping = false;
					this.localDragon.vy = 0;
				}
				this.localDragon.sprite.y += this.localDragon.vy;
			
				// Idle until the server tells the client who won.
				this.bgm.stop();
				this.scroll();
				this.trackSpeed -= 0.1;
				if(this.trackSpeed <= 0){
					this.trackSpeed = 0;
					this.localDragon.sprite.animations.stop();
				}
				break;
			
		}
	},
	
	scroll: function(){
		this.localDragon.sprite.x += this.trackSpeed;
		for(var index in this.track){
			var trackEnt = this.track[index];
			if(trackEnt.parallax && trackEnt.sprite){
				trackEnt.sprite.x += this.trackSpeed * trackEnt.parallax;
			}
		}
	},
	
	checkTrack: function(){
		var dragon = this.localDragon.sprite;
		
		for(var index in this.track){
			var trackEnt = this.track[index];
			
			switch(trackEnt.type){
				case "finishLine":
					if(this.localDragon.sprite.x >= trackEnt.sprite.x){
						this.subState = "Waiting";
						
					}
					break;
				case "hurdle":
				case "flyingHurdle":
					if(!trackEnt.triggered){
						// Check positions to see if local dragon triggers this hurdle.
						
						var hurdle = trackEnt.sprite;
						var xCollision = dragon.x > hurdle.x - hurdle.width/2 - (dragon.width * 0.60)/2 && dragon.x < hurdle.x + hurdle.width/2 + (dragon.width*0.60)/2;
						var yCollision = dragon.y > hurdle.y - hurdle.height && dragon.y < hurdle.y + dragon.height;
						if(xCollision && yCollision){
							trackEnt.triggered = true;
							hurdle.angle = 90;
							this.trackSpeed /= 2;
						}
					}
					break;
				case "flyMarker":
					
					if(!trackEnt.triggered && dragon.x >= trackEnt.x - 150){
						this.trackMode = "sky";
						this.localDragon.vy = -20;
						this.localDragon.jumping = true;
						trackEnt.triggered = true;
					}
					break;
				case "runMarker":
					if(!trackEnt.triggered && dragon.x >= trackEnt.x + 200){
						this.trackMode = "land";
						trackEnt.triggered = true;
					}
					break;
			}
		}
	},
	
	 keyDown: function(keyEvent){
		if(!this.keyPoll[keyEvent.code]){
			// key switched from up to down. Avoids the event flood that comes from holding a key down
			this.keyPoll[keyEvent.code] = true;
			
			// Forward these actual key down events to the server (but only for relevant keys)
			if(["KeyW", "KeyS", "Space"].indexOf(keyEvent.code) != -1){
				socket.emit("keyDown", {keyCode : keyEvent.code});
			}
			
			// Do trigger actions based on the input
			switch(keyEvent.code){
				case "KeyW":
				case "Space":
					if(this.subState == "Racing" && this.trackMode == "land" && !this.localDragon.jumping){
						// Jump!
						this.localDragon.jumping = true;
						this.localDragon.vy = -20;
					}
					break;
				case "KeyS":
					if(this.trackMode == "land"){
						// Fireball!
					}
					break;
			}
		}
	},
	
	keyUp: function(keyEvent){
		this.keyPoll[keyEvent.code] = false;
		if(["KeyW", "KeyS", "Space"].indexOf(keyEvent.code) != -1){
			socket.emit("keyUp", {keyCode : keyEvent.code});
		}
	}
};

var ordinalSuffix = function(number){
	var str = number.toString();
	switch(str[str.length - 1]){
		case '1':
			return "st";
		case '2':
			return "nd";
		case '3':
			return "rd";
		default:
			return "th";		
	}
	
}